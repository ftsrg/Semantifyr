package Test

// Event.oxsts

type Event {
    var isActive: Boolean = false

    tran set {
        isActive := true
    }

    tran reset {
        isActive := false
    }

    havoc {
        havoc (isActive)
    }

    tran isSet {
        assume (isActive)
    }
}

type Timeout {
    var deltaTime : Integer = 0

    tran {
        if (deltaTime > 0) {
            deltaTime := deltaTime - 1501
        }
    }

    tran isUp {
        assume (deltaTime <= 0)
    }
}

// Trigger.oxsts

type Trigger {
    virtual tran isTriggered { }
}

type EventTrigger : Trigger {
    reference event : Event[1..1]

    override tran isTriggered {
        inline event.isSet()
    }
}

type TimeoutTrigger : Trigger {
    reference timeout : Timeout[1..1]

    override tran isTriggered {
        inline timeout.isUp()
    }
}

// Action.oxsts

type Action {
    virtual tran { }
}

type RaiseEventAction : Action {
    reference event : Event[1..1]

    override tran {
        inline event.set()
    }
}

type SetTimeoutAction : Action {
    reference timeout : Timeout[1..1]
    reference delta : Integer = 1000

    override tran {
        timeout.deltaTime := delta
    }
}

type Guard {
    virtual tran { }
}

// Component.oxsts

type Component {
    virtual init { }
    virtual tran { }
}

type Channel {
    reference inputEvent : Event
    reference outputEvent : Event

    tran {
        if (inputEvent.isActive) {
            inline outputEvent.set()
        }
    }
}

type CompositeComponent : Component {
    feature components : Component
    feature channels : Channel
}

type SyncComponent : CompositeComponent {
    override init {
        inline seq components -> init
    }

    override tran {
        inline seq components -> main
        inline seq channels -> main
    }
}

// Statechart.oxsts

type Statechart : Component {
    feature events : Event[0..*]
    feature inputEvents :> events : Event[0..*]
    feature outputEvents :> events : Event[0..*]

    feature timeouts : Timeout[0..*]

    feature regions : Region[0..*]

    override init {
        inline seq regions -> activateRecursive
    }

    override tran {
        inline seq outputEvents -> reset
        choice {
            inline seq regions -> fireTransitions
        } else { }
        inline seq inputEvents -> reset
        inline seq timeouts -> main
    }
}

type Region {
    feature states : State[0..*]

    var activeState : states[0..1] = Nothing

    feature abstractTransitions : AbstractTransition[0..*]

    feature transitions :> abstractTransitions : Transition[0..*]
    feature entryTransitions :> abstractTransitions : EntryTransition[0..*]

    tran activateRecursive {
        inline seq entryTransitions -> main
    }

    tran deactivateRecursive {
        inline seq states -> deactivateRecursive
    }

    tran fireTransitions {
        inline choice transitions -> main else {
            inline choice states -> fireTransitions
        }
        /*inline choice states -> fireTransitions else {
            inline choice transitions -> main
        }*/
    }

    tran fireTransitionsInner {
        inline choice transitions -> main
    }
}

type State {
    reference parent : Region[0..1]
    reference parentState : State[0..1]
    feature regions : Region[0..1]

    feature entryActions : Action[0..*]
    feature exitActions : Action[0..*]

    tran isActive {
        assume (parent.activeState == Self)
    }

    tran deactivateRecursive {
        inline seq regions -> deactivateRecursive

        if (parent.activeState == Self) {
            parent.activeState := Nothing
            inline seq exitActions -> main
        }
    }

    tran exitRecursive(commonRegion : Region) {
        inline seq exitActions -> main

        parent.activeState := Nothing

        inline if (commonRegion != parent) {
            inline parentState.exitRecursive(commonRegion)
        }
    }

    tran exit(commonRegion : Region) {
        inline exitRecursive(commonRegion)

        inline seq regions -> deactivateRecursive
    }

    tran enterRecursive(commonRegion : Region) {
        inline if (commonRegion != parent) {
            inline parentState.enterRecursive(commonRegion)
        }

        parent.activeState := Self

        inline seq entryActions -> main
    }

    tran enter(commonRegion : Region) {
        inline enterRecursive(commonRegion)

        inline seq regions -> activateRecursive
    }

    tran fireTransitions {
        inline seq regions -> fireTransitions
    }
}

type AbstractTransition {
    reference commonRegion : Region[1..1]
    reference to : State[1..1]

    virtual tran { }
}

type EntryTransition : AbstractTransition {
    override tran {
        inline to.enter(commonRegion)
    }
}

type Transition : AbstractTransition {
    reference from : State[0..1]

    feature trigger : Trigger
    feature actions : Action[0..*]
    feature guards : Guard[0..*]

    tran {
        inline seq guards -> main
        inline trigger.isTriggered()
        inline from.isActive()

        inline from.exit(commonRegion)
        inline seq actions -> main
        inline to.enter(commonRegion)
    }
}

// Station.oxsts

type Station : Statechart {
    containment dataEvent :> inputEvents : Event
    containment pingEvent :> outputEvents : Event

    containment startEvent :> inputEvents : Event
    containment shutdownEvent :> inputEvents : Event

    containment pingTimeout :> timeouts : Timeout
    containment startTimeout :> timeouts : Timeout

    var receivedData : Integer = 0

    containment Main :> regions : Region {
        containment et1 :> entryTransitions : EntryTransition {
            reference ::> commonRegion : Region = Main
            reference ::> to : State = Idle
        }

        containment Idle :> states : State {
            reference ::> parent : Region = Main

            containment ea1 :> entryActions : SetTimeoutAction {
                reference ::> timeout : Timeout = startTimeout
                reference ::> delta : Integer = 15000
            }
        }

        containment startOperation :> transitions : Transition {
            reference ::> commonRegion : Region = Main
            reference ::> from : State = Idle
            reference ::> to : State = Operation

            containment t :> trigger : EventTrigger {
                reference ::> event : Event = startEvent
            }
        }

        containment autoStartOperation :> transitions : Transition {
            reference ::> commonRegion : Region = Main
            reference ::> from : State = Idle
            reference ::> to : State = Operation

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = startTimeout
            }
        }

        containment shutdownOperation :> transitions : Transition {
            reference ::> commonRegion : Region = Main
            reference ::> from : State = Operation
            reference ::> to : State = Idle

            containment t :> trigger : EventTrigger {
                reference ::> event : Event = shutdownEvent
            }
        }

        containment Operation :> states : State {
            reference ::> parent : Region = Main

            containment ea1 :> entryActions : SetTimeoutAction {
                reference ::> timeout : Timeout = pingTimeout
                reference ::> delta : Integer = 10000
            }
            containment ea2 :> entryActions : RaiseEventAction {
                reference ::> event : Event = pingEvent
            }

            containment ReceiveData :> regions : Region {
                containment et2 :> entryTransitions : EntryTransition {
                    reference ::> commonRegion : Region = ReceiveData
                    reference ::> to : State = Waiting
                }

                containment Waiting :> states : State {
                    reference ::> parent : Region = ReceiveData
                    reference ::> parentState : State = Operation
                }

                containment receivedDataOperation :> transitions : Transition {
                    reference ::> commonRegion : Region = ReceiveData
                    reference ::> from : State = Waiting
                    reference ::> to : State = Waiting

                    containment t :> trigger : EventTrigger {
                        reference ::> event : Event = dataEvent
                    }
                    containment a :> actions : Action {
                        tran {
                            receivedData := receivedData + 1
                        }
                    }
                }
            }
        }

        containment resendPing :> transitions : Transition {
            reference ::> commonRegion : Region = Main
            reference ::> from : State = Operation
            reference ::> to : State = Operation

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = pingTimeout
            }
        }
    }
}

// TrafficLightCtrl.oxsts

type Spacecraft : Statechart {
    containment pingEvent :> inputEvents : Event
    containment dataEvent :> outputEvents : Event

    containment rechargeTimeout :> timeouts : Timeout
    containment consumeTimeout :> timeouts : Timeout
    containment transmitTimeout :> timeouts : Timeout

    var batteryCharge : Integer = 100
    var recharging : Boolean = false
    var data : Integer = 10

    containment Communication :> regions : Region {
        containment et1 :> entryTransitions : EntryTransition {
            reference ::> commonRegion : Region = Communication
            reference ::> to : State = WaitingPing
        }

        containment WaitingPing :> states : State {
            reference ::> parent : Region = Communication
        }

        containment receivedPing :> transitions : Transition {
            reference ::> commonRegion : Region = Communication
            reference ::> from : State = WaitingPing
            reference ::> to : State = Transmitting

            containment t :> trigger : EventTrigger {
                reference ::> event : Event = pingEvent
            }
            containment g :> guards : Guard {
                override tran {
                    assume (recharging == false)
                }
            }
        }

        containment lowBattery :> transitions : Transition {
            reference ::> commonRegion : Region = Communication
            reference ::> from : State = Transmitting
            reference ::> to : State = WaitingPing

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = consumeTimeout
            }
            containment g :> guards : Guard {
                override tran {
                    assume (batteryCharge < 40)
                }
            }
        }

        containment lowBatteryOrDone :> transitions : Transition {
            reference ::> commonRegion : Region = Communication
            reference ::> from : State = Transmitting
            reference ::> to : State = WaitingPing

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = transmitTimeout
            }
            containment g :> guards : Guard {
                override tran {
                    assume (data <= 1 || batteryCharge < 40)
                }
            }
        }

        containment Transmitting :> states : State {
            reference ::> parent : Region = Communication

            containment SendData :> regions : Region {
                containment et2 :> entryTransitions : EntryTransition {
                    reference ::> commonRegion : Region = SendData
                    reference ::> to : State = Sending
                }

                containment Sending :> states : State {
                    reference ::> parent : Region = SendData
                    reference ::> parentState : State = Transmitting

                    containment ea1 :> entryActions : SetTimeoutAction {
                        reference ::> timeout : Timeout = transmitTimeout
                        reference ::> delta : Integer = 1500
                    }
                }

                containment transmitData :> transitions : Transition {
                    reference ::> commonRegion : Region = SendData
                    reference ::> from : State = Sending
                    reference ::> to : State = Sending

                    containment t :> trigger : TimeoutTrigger {
                        reference ::> timeout : Timeout = transmitTimeout
                    }
                    containment g :> guards : Guard {
                        override tran {
                            assume (data > 1 && batteryCharge >= 40)
                        }
                    }
                    containment a1 :> actions : Action {
                        override tran {
                            data := data - 1
                        }
                    }
                    containment a2 :> actions : RaiseEventAction {
                        reference ::> event : Event = dataEvent
                    }
                }
            }

            containment ConsumePower :> regions : Region {
                containment et2 :> entryTransitions : EntryTransition {
                    reference ::> commonRegion : Region = ConsumePower
                    reference ::> to : State = Consuming
                }

                containment Consuming :> states : State {
                    reference ::> parent : Region = ConsumePower
                    reference ::> parentState : State = Transmitting

                    containment ea1 :> entryActions : SetTimeoutAction {
                        reference ::> timeout : Timeout = consumeTimeout
                        reference ::> delta : Integer = 1000
                    }
                }

                containment consumePower :> transitions : Transition {
                    reference ::> commonRegion : Region = ConsumePower
                    reference ::> from : State = Consuming
                    reference ::> to : State = Consuming

                    containment t :> trigger : TimeoutTrigger {
                        reference ::> timeout : Timeout = consumeTimeout
                    }
                    containment g :> guards : Guard {
                        override tran {
                            assume (batteryCharge >= 40)
                        }
                    }
                    containment a :> actions : Action {
                        override tran {
                            batteryCharge := batteryCharge - 10
                        }
                    }
                }
            }
        }
    }

    containment Battery :> regions : Region {
        containment et1 :> entryTransitions : EntryTransition {
            reference ::> commonRegion : Region = Battery
            reference ::> to : State = NotRecharging
        }

        containment NotRecharging :> states : State {
            reference ::> parent : Region = Battery

            containment ea1 :> entryActions : Action {
                tran {
                    recharging := false
                }
            }
        }

        containment startRecharging :> transitions : Transition {
            reference ::> commonRegion : Region = Battery
            reference ::> from : State = NotRecharging
            reference ::> to : State = Recharging

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = consumeTimeout
            }
            containment g :> guards : Guard {
                override tran {
                    assume (batteryCharge < 80)
                }
            }
        }

        containment recharge :> transitions : Transition {
            reference ::> commonRegion : Region = Battery
            reference ::> from : State = Recharging
            reference ::> to : State = Recharging

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = rechargeTimeout
            }
            containment g :> guards : Guard {
                override tran {
                    assume (batteryCharge < 100)
                }
            }
            containment a :> actions : Action {
                override tran {
                    batteryCharge := batteryCharge + 10
                }
            }
        }

        containment stopRecharging :> transitions : Transition {
            reference ::> commonRegion : Region = Battery
            reference ::> from : State = Recharging
            reference ::> to : State = NotRecharging

            containment t :> trigger : TimeoutTrigger {
                reference ::> timeout : Timeout = rechargeTimeout
            }
            containment g :> guards : Guard {
                override tran {
                    assume (batteryCharge == 100)
                }
            }
        }

        containment Recharging :> states : State {
            reference ::> parent : Region = Battery

            containment ea1 :> entryActions : SetTimeoutAction {
                reference ::> timeout : Timeout = rechargeTimeout
                reference ::> delta : Integer = 10000
            }
            containment ea2 :> entryActions : Action {
                tran {
                    recharging := true
                }
            }
        }
    }
}

type SpaceMission : SyncComponent {
    containment spacecraft :> components : Spacecraft
    containment station :> components : Station

    containment pingChannel :> channels : Channel {
        reference ::> inputEvent : Event = station.pingEvent
        reference ::> outputEvent : Event = spacecraft.pingEvent
    }
    containment dataChannel :> channels : Channel {
        reference ::> inputEvent : Event = spacecraft.dataEvent
        reference ::> outputEvent : Event = station.dataEvent
    }
}

target Mission {
    containment spaceMission : SpaceMission

    init {
        inline spaceMission.init()
    }

    tran {
        inline spaceMission.station.startEvent.havoc()
        inline spaceMission.station.shutdownEvent.havoc()
        inline spaceMission.main()
    }

    prop {
        true
    }
}

target StationIdle_Unsafe : Mission {
    prop {
       ! (spaceMission.station.Main.activeState == spaceMission.station.Main.Idle)
    }
}

target StationOperation_Unsafe : Mission {
    prop {
       ! (spaceMission.station.Main.activeState == spaceMission.station.Main.Operation)
    }
}

target StationOperationWaiting_Unsafe : Mission {
    prop {
       ! (spaceMission.station.Main.Operation.ReceiveData.activeState == spaceMission.station.Main.Operation.ReceiveData.Waiting)
    }
}

target SpacecraftWaitingPing_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.Communication.activeState == spaceMission.spacecraft.Communication.WaitingPing)
    }
}

target SpacecraftTransmitting_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.Communication.activeState == spaceMission.spacecraft.Communication.Transmitting)
    }
}

target SpacecraftTransmittingSending_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.Communication.Transmitting.SendData.activeState == spaceMission.spacecraft.Communication.Transmitting.SendData.Sending)
    }
}

target SpacecraftTransmittingConsuming_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.Communication.Transmitting.ConsumePower.activeState == spaceMission.spacecraft.Communication.Transmitting.ConsumePower.Consuming)
    }
}

target SpacecraftNotRecharging_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.Battery.activeState == spaceMission.spacecraft.Battery.NotRecharging)
    }
}

target SpacecraftRecharging_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.Battery.activeState == spaceMission.spacecraft.Battery.Recharging)
    }
}

target Station_ReceivedData_0_Unsafe : Mission {
    prop {
       ! (spaceMission.station.receivedData == 0)
    }
}

target Station_ReceivedData_1_Unsafe : Mission {
    prop {
       ! (spaceMission.station.receivedData == 1)
    }
}

target Station_ReceivedData_5_Unsafe : Mission {
    prop {
       ! (spaceMission.station.receivedData == 5)
    }
}

target Station_ReceivedData_9_Unsafe : Mission {
    prop {
       ! (spaceMission.station.receivedData == 9)
    }
}

target Station_ReceivedData_10_Unsafe : Mission {
    prop {
       ! (spaceMission.station.receivedData == 10)
    }
}

target Spacecraft_data_10_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 10)
    }
}

target Spacecraft_data_9_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 9)
    }
}

target Spacecraft_data_5_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 5)
    }
}

target Spacecraft_data_3_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 3)
    }
}

target Spacecraft_data_2_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 2)
    }
}

target Spacecraft_data_1_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 1)
    }
}

target Spacecraft_data_0_Unsafe : Mission {
    prop {
       ! (spaceMission.spacecraft.data == 0)
    }
}

target Spacecraft_batteryCharge_100_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge == 100)
    }
}

target Spacecraft_batteryCharge_90_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge == 90)
    }
}

target Spacecraft_batteryCharge_80_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge == 80)
    }
}

target Spacecraft_batteryCharge_70_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge == 70)
    }
}

target Spacecraft_batteryCharge_40_Unsafe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge == 40)
    }
}

target Data_is_never_lost_Safe : Mission {
    prop {
       spaceMission.station.receivedData == 10 - spaceMission.spacecraft.data
    }
}

target Spacecraft_batteryCharge_never_under_40_Safe : Mission {
    prop {
        ! (spaceMission.spacecraft.batteryCharge <= 40)
    }
}
