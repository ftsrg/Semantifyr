// automatically generated by Xtext
grammar hu.bme.mit.gamma.oxsts.lang.Oxsts with org.eclipse.xtext.common.Terminals

import "http://www.bme.hu/mit/gamma/oxsts" 
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

Package:
	{Package}
	'package' name=ID
	(types+=Type)*
;

Type:
	{Type}
	(isAbstract?='abstract')? 'type' name=ID (':' supertype=[Type])? ('{'
		(
			variables+=Variable
			| features+=Feature
			| 'init' initTransition+=NamelessTransition
			| 'tran' transitions+=NamedTransition
			| 'tran' mainTransition+=NamelessTransition
			| 'havoc' havocTransition+=NamelessTransition
			| InstanceHolder
			| (
				'prop' '{'
					invariant+=Expression
				'}'
			)
		)*
	'}')?
;

Instance: 
	'instance' name=ID ':>' feature=[Feature] ':' type=[Type]
	(
		'{'
			InstanceHolder*
		'}'
	)?
;

fragment InstanceHolder returns InstanceHolder:
	instances+=Instance
	| bindings+=InstanceBinding
;

InstanceBinding:
	'reference' feature=ReferenceExpression '=' instance=ReferenceExpression
;


NamedTransition returns Transition:
	name=ID ('('')')? TransitionBody
;

NamelessTransition returns Transition:
	TransitionBody
;

fragment TransitionBody returns Transition:
	operation+=SequenceOperation
	(
		'or' operation+=SequenceOperation
	)*
;

Operation:
	   HavocOperation
	 | ChoiceOperation
	 | SequenceOperation
	 | AssumptionOperation
	 | InlineOperation
	 | AssignmentOperation
	 | IfOperation
;

SequenceOperation:
	'{'
		(operation+=Operation)+
	'}'
;

HavocOperation:
	'havoc' '(' referenceExpression=ReferenceExpression ')'
;

ChoiceOperation:
	'choice' operation+=SequenceOperation
	(
		'or' operation+=SequenceOperation
	)*
	(
		'else' '{' '}' |
		'else' else=SequenceOperation
	)?
;

AssumptionOperation: 
	'assume' '(' expression=Expression ')'
;

IfOperation: 
	'if' '(' guard=Expression ')'
	body = SequenceOperation
	(
		'else' else=SequenceOperation
	)?
;

InlineOperation: 
	InlineCall
	| InlineChoice
	| InlineSeq
	| InlineIfOperation
;

InlineChoice: 
	'inline' 'choice' feature=ReferenceExpression '->' transition=ReferenceExpression 
	(
		'else' '{' '}' |
		'else' else=SequenceOperation
	)?
;

InlineSeq: 
	'inline' 'seq' feature=ReferenceExpression '->' transition=ReferenceExpression
;

InlineCall: 
	'inline' reference=ReferenceExpression '(' ')'
;

InlineIfOperation: 
	'inline' 'if' '(' guard=Expression ')'
	body = SequenceOperation
	(
		'else' else=SequenceOperation
	)?
;


AssignmentOperation: 
	reference=ReferenceExpression ':=' expression=Expression
;



Variable:
	'var' name=ID ':' typing=VariableTyping /*(multiplicity=Multiplicity)?*/ (':=' expression=Expression)? 
;

Feature:
	(isReference?='reference' | 'feature') name=ID (':>' subsets=[Feature])? ':' type=[Type] (multiplicity=Multiplicity)?
;

Multiplicity: 
	OptionalMultiplicity
	| OneMultiplicity
	| ManyMultiplicity
;

OptionalMultiplicity: 
	{OptionalMultiplicity} '[0..1]'
;

OneMultiplicity: 
	{OneMultiplicity} '[1..1]'
;

ManyMultiplicity: 
	{ManyMultiplicity} '[0..*]'
;


VariableTyping: 
	EnumType
	| DataType
;


EnumType: 
	feature=[Feature]
;


DataType: 
	IntegerType 
	| BooleanType
;

IntegerType: 
	{IntegerType} 'Integer'
;

BooleanType: 
	{BooleanType} 'Boolean'
;




// Expressions

Expression: 
	OperatorExpression
;


// Operator expressions

OperatorExpression returns Expression:
	OrOperator
;

OrOperator returns Expression: 
	AndOperator ({OrOperator.operands+=current} '||' operands+=AndOperator)*
;

AndOperator returns Expression: 
	PlusOperator ({AndOperator.operands+=current} '&&' operands+=PlusOperator)*
;

PlusOperator returns Expression: 
	MinusOperator ({PlusOperator.operands+=current} '+' operands+=MinusOperator)*
;

MinusOperator returns Expression: 
	EqualityOperator ({MinusOperator.operands+=current} '-' operands+=EqualityOperator)*
;

EqualityOperator returns Expression: 
	InequalityOperator ({EqualityOperator.operands+=current} '=' operands+=InequalityOperator)*
;

InequalityOperator returns Expression: 
	UnaryOperator ({InequalityOperator.operands+=current} '!=' operands+=UnaryOperator)*
;

UnaryOperator returns Expression:
	NotOperator
	| PrimaryExpression
;

NotOperator returns NotOperator: 
	{NotOperator} => ('not' | '!') operands+=PrimaryExpression
;

// Reference expressions

PrimaryExpression returns Expression:
	  ReferenceExpression
	| LiteralExpression
	| '(' Expression ')'
;

ReferenceExpression returns ReferenceExpression: 
	  DirectReferenceExpression
	| ChainReferenceExpression
;

DirectReferenceExpression: 
	DeclarationReferenceExpression
	| ImplicitTransitionExpression
;

ImplicitTransitionExpression: 
	InitTransitionExpression
	| HavocTransitionExpression
	| MainTransitionExpression
;

DeclarationReferenceExpression: 
	element=[Element]
;

InitTransitionExpression: 
	{InitTransitionExpression} 'init'
;

HavocTransitionExpression: 
	{HavocTransitionExpression} 'havoc'
;

MainTransitionExpression: 
	{MainTransitionExpression} 'main'
;

ChainReferenceExpression: 
	chains+=ChainingExpression
	(
		'.' chains+=ChainingExpression
	)+
;

ChainingExpression: 
	element=[Element]
;

// Literal expressions

LiteralExpression:
	   LiteralBoolean
	 | LiteralInteger
	 | LiteralNothing
	 | LiteralSelf
;

LiteralBoolean:
	value = BooleanValue
;

LiteralInteger:
	value = INT
;

LiteralNothing:
	{LiteralNothing} 'Nothing'
;

LiteralSelf: 
	{LiteralSelf} 'Self'
;


BooleanValue returns Ecore::EBoolean:
	'true' | 'false'
;
