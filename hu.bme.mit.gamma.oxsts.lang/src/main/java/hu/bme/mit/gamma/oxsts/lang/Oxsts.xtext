// automatically generated by Xtext
grammar hu.bme.mit.gamma.oxsts.lang.Oxsts with org.eclipse.xtext.common.Terminals

import "http://www.bme.hu/mit/2023/oxsts" 
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

Package:
	'package' name=ID
	(
		  types += Type
		| enums += Enum
		| target += Target
	)*
;

Target:
	(abstract?='abstract')? 'target' name=ID (':' supertype=[Type])? ('{'
        (
            variables+=Variable
            | instances+=TargetInstance
//            | features+=FeatureLike
            | initTransition+=InitTransition
            | 'tran' transitions+=NamedTransition
            | mainTransition+=MainTransition
//            | havocTransition+=HavocTransition
            | properties+=Property
        )*
    '}')?
;

Property:
	  NamedProperty
	| NamelessProperty
;

NamedProperty returns Property:
	'prop' name=ID '{'
		invariant=Expression
	'}'
;

NamelessProperty returns Property:
	'prop' '{'
		invariant=Expression
	'}'
;

Enum: 
	'enum' name=ID '{'
		literals+=EnumLiteral (',' literals+=EnumLiteral)* (',')?
	'}'
;

EnumLiteral:
	name=ID
;

Type:
	(abstract?='abstract')? 'type' name=ID (':' supertype=[Type])? ('{'
		(
			variables+=Variable
			| features+=FeatureLike
			| initTransition+=InitTransition
			| 'tran' transitions+=NamedTransition
			| mainTransition+=MainTransition
			| havocTransition+=HavocTransition
			| properties+=Property
		)*
	'}')?
;

NamedTransition returns Transition:
	TransitionModifier name=ID TransitionBody
;

fragment NamelessTransition returns Transition:
	TransitionBody
;

HavocTransition returns Transition:
	TransitionModifier 'havoc' NamelessTransition
;

MainTransition returns Transition:
	TransitionModifier 'tran' NamelessTransition
;

InitTransition returns Transition:
	TransitionModifier 'init' NamelessTransition
;

fragment TransitionModifier returns Transition:
	(virtual?='virtual' | override?='override')?
;

fragment TransitionBody returns Transition:
	('('
		parameters+=Parameter
		(',' parameters+=Parameter)* (',')?
	')')? 
	operation+=SequenceOperation
	(
		'or' operation+=SequenceOperation
	)*
;

Parameter: 
	name=ID ':' type=[Type]
;


Operation:
	   HavocOperation
	 | ChoiceOperation
	 | SequenceOperation
	 | AssumptionOperation
	 | InlineOperation
	 | AssignmentOperation
	 | IfOperation
;

SequenceOperation:
	'{'
		(operation+=Operation)+
	'}'
;

HavocOperation:
	'havoc' '(' referenceExpression=ReferenceExpression ')'
;

ChoiceOperation:
	'choice' operation+=SequenceOperation
	(
		'or' operation+=SequenceOperation
	)*
	(
		'else' '{' '}' |
		'else' else=SequenceOperation
	)?
;

AssumptionOperation: 
	'assume' '(' expression=Expression ')'
;

IfOperation: 
	'if' '(' guard=Expression ')'
	body = SequenceOperation
	(
		'else' else=SequenceOperation
	)?
;

InlineOperation: 
	InlineCall
	| InlineChoice
	| InlineSeq
	| InlineIfOperation
;

InlineChoice: 
	'inline' 'choice' feature=ReferenceExpression '->' transition=ReferenceExpression 
	(
		'else' '{' '}' |
		'else' else=SequenceOperation
	)?
;

InlineSeq: 
	'inline' 'seq' feature=ReferenceExpression '->' transition=ReferenceExpression
;

InlineCall: 
	'inline' reference=ReferenceExpression '('
		parameterBindings+=ParameterBinding
		(',' parameterBindings+=ParameterBinding)* (',')?
	')'
;

ParameterBinding: 
	expression=Expression
;


InlineIfOperation: 
	'inline' 'if' '(' guard=Expression ')'
	body = SequenceOperation
	(
		'else' else=SequenceOperation
	)?
;


AssignmentOperation: 
	reference=ReferenceExpression ':=' expression=Expression
;



Variable:
	'var' name=ID ':' typing=VariableTyping (':=' expression=Expression)?
;

FeatureLike returns Feature:
	Feature
	| Instance
;

Feature:
	(reference?='reference' | 'feature') name=ID (':>' subsets=[Feature])? ':' type=[Type] (multiplicity=Multiplicity)?
;

TargetInstance returns Instance:
	'instance' name=ID ':' type=[Type]
	(
		'{'
			(instances+=Instance | bindings+=InstanceBinding)*
		'}'
	)?
;

Instance: 
	'instance' name=ID ':>' subsets=[Feature] ':' type=[Type]
	(
		'{'
			(instances+=Instance | bindings+=InstanceBinding)*
		'}'
	)?
;

InstanceBinding:
	'reference' feature=ReferenceExpression '<-' instance=ReferenceExpression
;

Multiplicity: 
	OptionalMultiplicity
	| OneMultiplicity
	| ManyMultiplicity
;

OptionalMultiplicity: 
	{OptionalMultiplicity} '[0..1]'
;

OneMultiplicity: 
	{OneMultiplicity} '[1..1]'
;

ManyMultiplicity: 
	{ManyMultiplicity} '[0..*]'
;


VariableTyping: 
	VariableTypeReference
	| DataType
;

VariableTypeReference: 
	reference=[VariableType] (optional?='[0..1]' | '[1..1]')?
;

DataType: 
	IntegerType 
	| BooleanType
;

IntegerType: 
	{IntegerType} 'Integer'
;

BooleanType: 
	{BooleanType} 'Boolean'
; 

// Expressions

Expression: 
	OperatorExpression
;


// Operator expressions

OperatorExpression returns Expression:
	OrOperator
;

OrOperator returns Expression: 
	AndOperator ({OrOperator.operands+=current} '||' operands+=AndOperator)*
;

AndOperator returns Expression: 
	PlusOperator ({AndOperator.operands+=current} '&&' operands+=PlusOperator)*
;

PlusOperator returns Expression: 
	MinusOperator ({PlusOperator.operands+=current} '+' operands+=MinusOperator)*
;

MinusOperator returns Expression: 
	EqualityOperator ({MinusOperator.operands+=current} '-' operands+=EqualityOperator)*
;

EqualityOperator returns Expression: 
	InequalityOperator ({EqualityOperator.operands+=current} '=' operands+=InequalityOperator)*
;

InequalityOperator returns Expression: 
	UnaryOperator ({InequalityOperator.operands+=current} '!=' operands+=UnaryOperator)*
;

UnaryOperator returns Expression:
	NotOperator
	| PrimaryExpression
;

NotOperator returns NotOperator: 
	{NotOperator} => ('not' | '!') operands+=NotOperator
;

// Reference expressions

PrimaryExpression returns Expression:
	  ReferenceExpression
	| LiteralExpression
	| '(' Expression ')'
;

ReferenceExpression returns ReferenceExpression: 
	ChainReferenceExpression
;

ChainReferenceExpression: 
	chains+=ChainingExpression
	(
		'.' chains+=ChainingExpression
	)+
;

ChainingExpression: 
	ImplicitTransitionExpression
	| DeclarationReferenceExpression
	| SelfReference
	| NothingReference
;

SelfReference:
	{SelfReference} 'Self'
;

NothingReference:
	{NothingReference} 'Nothing'
;


ImplicitTransitionExpression: 
	InitTransitionExpression
	| HavocTransitionExpression
	| MainTransitionExpression
;

InitTransitionExpression: 
	{InitTransitionExpression} 'init'
;

HavocTransitionExpression: 
	{HavocTransitionExpression} 'havoc'
;

MainTransitionExpression: 
	{MainTransitionExpression} 'main'
;

DeclarationReferenceExpression: 
	element=[Element|FQN]
;

FQN:
    ID ('::' ID)*
;

// Literal expressions

LiteralExpression:
	   LiteralBoolean
	 | LiteralInteger
;

LiteralBoolean:
	value = BooleanValue
;

LiteralInteger:
	value = INT
;

BooleanValue returns Ecore::EBoolean:
	'true' | 'false'
;
