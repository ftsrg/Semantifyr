type Statechart : AtomicComponent {
    feature ports : Port[0..*]
    feature region : Region
    feature transitions : Transition[0..*]
    feature timeouts : Timeout[0..*]

    derived feature entryTransitions :> transitions : EntryTransition[0..*]

    init {
        seq inline entryTransitions // execute
    }

    tran {
        choice inline transitions /*execute*/ else { }

        seq inline ports Port::reset
    }
}

type Region {
    feature abstractStates : AbstractState[0..*] // derived?
    feature states :> abstractStates : State[0..*]
    feature entryStates :> abstractStates : EntryState[0..*]

    var activeState : states[0..1] := Nothing
}

abstract type AbstractState {
    reference parentRegion: Region derived as Region.states(parentRegion, Self);
    derived reference parentState: State[0..1] := Nothing

    tran exit(commonAncestor: Region) {
        parentRegion.activeState := Nothing

        inline if (parentRegion != commonAncestor) {
            inline parentState.exit(commonAncestor)
        }
    }
    tran enter(commonAncestor: Region) {
        inline if (parentRegion != commonAncestor) {
            inline parentState.enter(commonAncestor)
        }

        parentRegion.activeState := Self
    }

    tran assumeActive() {
        assume (parentRegion.activeState == Self)
    }

    evaluate pattern {

    }

    evaluate pattern {
        State.region(parentState, parentRegion);
    }
}

type State : AbstractState {
    feature region : Region
}
type EntryState : AbstractState

pattern hasLowerCommonAncestorRegion(region : Region, state1 : State, state2 : State) {
    find subregion(region, subregion);
    find commonAncestorRegion(subregion, state1, state2);
}

pattern commonAncestorRegion(region : Region, state1 : State, state2 : State) {
    state1 != state2;
    find substate(region, state1);
    find substate(region, state2);
}

pattern subregion(region: Region, subregion: Region) {
    Region.states(region, substate);
    State.region(substate, subregion);
}

pattern substate(region: Region, substate: State) {
    Region.states(region, substate);
} or {
    Region.states(region, state);
    find substate+(state, substate)
}

pattern substate(state: State, substate: State) {
    State.region(state, region);
    Region.states(region, substate);
}

// lehetne használni ocl szerű subsetet, mondjuk valami egyszerűbb függvényeket
// kerml-t használni saját nyelv helyett? mivel kéne kiegészíteni a kerml-t?
// függvény hívás, egyéb fordításidőben processzálás
//
// vql-ből lehetne származni, és a különböző expression-öket ki lehet egészíteni a saját típusokkal, amit aztán postprocessinggel kijavítani és futtatni
//
// typon belül vql írása?
//
// minden type, reference-re vagy feature-re is lehet type-ként hivatkozni, ilyenkor rá, mint enumra hivatkozunk
// var state[0..1]: state

abstract type Transition {
    reference from : State
    reference to : State

    derived reference commonAncestor : Region // as vql Patterns::valami
    // derived reference commonAncestor : Region := Region::lowestCommonAncestor(from, to) // this could be an ocl-like expression

    evaluate pattern {
        find commonAncestorRegion(commonAncestor, from, to);
        not find hasLowerCommonAncestorRegion(commonAncestor, from, to);
    }
}

type EntryTransition : Transition {
    reference :> from : EntryState

    tran {
        inline to.enter(commonAncestor)
    }
}

type TriggeredTransition : Transition {
    feature trigger : Boolean

    tran {
        inline trigger.assumeTriggered()

        inline from.exit(commonAncestor)
        inline to.enter(commonAncestor)
    }
}
