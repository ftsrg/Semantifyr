type Statechart : AtomicComponent {
    feature ports : Port[0..*]
    feature region : Region
    feature transitions : Transition[0..*]

    derived feature entryTransitions :> transitions : EntryTransition[0..*]

    init {
        seq inline entryTransitions Transition::execute
    }

    tran execute() {
        choice inline transitions Transition::execute else { }

        seq inline ports Port::reset
    }
}

type Region {
    feature abstractStates : AbstractState[0..*]
    feature states :> abstractStates : State[0..*]
    feature entryStates :> abstractStates : EntryState[0..*]

    var activeState : states[0..1] := Nothing
}

abstract type AbstractState {
    reference parentRegion: Region
    reference parentState: State[0..1]

    tran exit(region: Region) {
        parentRegion.activeState := Nothing

        inline if (parentRegion != region) {
            inline parentState.exit(region)
        }
    }
    tran enter(region: Region) {
        inline if (parentRegion != region) {
            inline parentState.enter(region)
        }

        parentRegion.activeState := Self
    }

    tran assumeActive() {
        assume(parentRegion.activeState == Self)
    }

    evaluate {
        vql Region.states(parentRegion, Self);
        vql State.region(parentState, parentRegion);
    }
}

type State : AbstractState {
    feature region : Region
}
type EntryState : AbstractState

pattern lowestCommonAncestorRegion(region : Region, state1 : State, state2 : State) {
    find commonAncestorRegion(region, state1, state2);
    not find hasLowerCommonAncestorRegion(region, state1, state2);
}

pattern hasLowerCommonAncestorRegion(region : Region, state1 : State, state2 : State) {
    find subregion(region, subregion);
    find commonAncestorRegion(subregion, state1, state2);
}

pattern commonAncestorRegion(region : Region, state1 : State, state2 : State) {
    state1 != state2;
    find substate(region, state1);
    find substate(region, state2);
}

pattern subregion(region: Region, subregion: Region) {
    Region.states(region, substate);
    State.region(substate, subregion);
}

pattern substate(region: Region, substate: State) {
    Region.states(region, substate);
} or {
    Region.states(region, state);
    find substate+(state, substate)
}

pattern substate(state: State, substate: State) {
    State.region(state, region);
    Region.states(region, substate);
}

lehetne használni ocl szerű subsetet, mondjuk valami egyszerűbb függvényeket
kerml-t használni saját nyelv helyett? mivel kéne kiegészíteni a kerml-t?
függvény hívás, egyéb fordításidőben processzálás

vql-ből lehetne származni, és a különböző expression-öket ki lehet egészíteni a saját típusokkal, amit aztán postprocessinggel kijavítani és futtatni

typon belül vql írása?

minden type, reference-re vagy feature-re is lehet type-ként hivatkozni, ilyenkor rá, mint enumra hivatkozunk
var state[0..1]: state

abstract type Transition {
    reference from : State
    reference to : State

    derived reference commonAncestor : Region as vql
    // derived reference commonAncestor : Region := Region::lowestCommonAncestor(from, to) // this could be an ocl-like expression

    abstract tran execute()

    pattern evaluateCommonAncestor(from, to) {
        find lowestCommonAncestorRegion(commonAncestor, from, to);
    }
}

type EntryTransition : Transition {
    reference :> from : EntryState

    override tran execute() {
        inline to.enter(commonAncestor)
    }
}

type TriggeredTransition : Transition {
    feature trigger : Boolean

    override tran execute() {
        inline trigger.assumeTriggered()

        inline from.exit(commonAncestor)
        inline to.enter(commonAncestor)
    }
}
